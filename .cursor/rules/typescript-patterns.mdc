---
globs: *.ts,*.tsx,src/**/*.ts,src/**/*.tsx
description: Padr√µes TypeScript espec√≠ficos para o projeto webhook mapper
---

# Padr√µes TypeScript - Webhook Mapper

## üéØ Configura√ß√£o Strict Mode OBRIGAT√ìRIA

```typescript
// tsconfig.json - SEMPRE usar estas configura√ß√µes
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "exactOptionalPropertyTypes": true
  }
}
```

## üìù Interfaces e Tipos Espec√≠ficos do Dom√≠nio

### EventStructure - Interface Central:
```typescript
// ‚úÖ Correto - Interface completa
export interface EventStructure {
  path: string;
  type: 'string' | 'number' | 'boolean' | 'object' | 'array' | 'null' | 'union';
  optional: boolean;
  children?: Map<string, EventStructure>;
  arrayItemType?: EventStructure;
  examples: any[];
  isTruncated?: boolean;
  originalType?: string;
}
```

### TruncateMetadata - Metadados de Truncamento:
```typescript
// ‚úÖ Correto - Tipos para truncamento
interface TruncateMetadata {
  hasTruncated: boolean;
  truncatedFields: TruncatedField[];
  originalSize: number;
  truncatedSize: number;
}

interface TruncatedField {
  path: string;
  originalLength: number;
  truncatedLength: number;
  type: 'base64' | 'json' | 'text';
}
```

## üîß Padr√µes de Classes de Servi√ßo

### Constructor Injection Pattern:
```typescript
// ‚úÖ Correto - Inje√ß√£o de depend√™ncias
export class EventAnalyzer {
  constructor(
    private readonly truncateService: TruncateService,
    private readonly logger: Logger
  ) {}
  
  // M√©todos p√∫blicos
  public analyzeEvent(event: any): AnalysisResult {
    // implementa√ß√£o
  }
  
  // M√©todos privados para l√≥gica interna
  private buildStructureMap(obj: any): EventStructure {
    // implementa√ß√£o
  }
}
```

### Return Types Expl√≠citos:
```typescript
// ‚úÖ Correto - Sempre definir tipos de retorno
async generateZodSchema(
  structure: EventStructure, 
  eventType: string
): Promise<string> {
  // implementa√ß√£o
}

// ‚ùå Incorreto - Tipo inferido
async generateZodSchema(structure: EventStructure, eventType: string) {
  // implementa√ß√£o
}
```

## üé® Generics e Utility Types

### Uso de Generics para Reutiliza√ß√£o:
```typescript
// ‚úÖ Correto - Generic para processamento
interface ProcessResult<T> {
  success: boolean;
  data?: T;
  error?: string;
  metadata: ProcessMetadata;
}

class EventProcessor<T = any> {
  async process(event: T): Promise<ProcessResult<T>> {
    // implementa√ß√£o
  }
}
```

### Utility Types para Transforma√ß√µes:
```typescript
// ‚úÖ Correto - Usar utility types
type EventMetadataUpdate = Partial<Pick<EventMetadata, 
  'lastSeen' | 'totalReceived' | 'schemaVersion'
>>;

type RequiredEventFields = Required<Pick<EventStructure,
  'path' | 'type' | 'optional'
>>;
```

## üõ°Ô∏è Error Handling Tipado

### Classe de Erro Personalizada:
```typescript
// ‚úÖ Correto - Erros tipados
export class WebhookProcessingError extends Error {
  constructor(
    message: string,
    public readonly eventType: string,
    public readonly originalError?: Error,
    public readonly context?: Record<string, any>
  ) {
    super(message);
    this.name = 'WebhookProcessingError';
  }
}

// Uso em m√©todos
async processEvent(event: any): Promise<void> {
  try {
    // processamento
  } catch (error) {
    throw new WebhookProcessingError(
      'Failed to process webhook event',
      event.eventType || 'unknown',
      error instanceof Error ? error : undefined,
      { eventId: event.id, timestamp: Date.now() }
    );
  }
}
```

### Result Pattern:
```typescript
// ‚úÖ Correto - Result pattern para opera√ß√µes que podem falhar
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

async function safeTruncateEvent(event: any): Promise<Result<TruncatedEvent>> {
  try {
    const result = await truncateService.truncate(event);
    return { success: true, data: result };
  } catch (error) {
    return { success: false, error: error as Error };
  }
}
```

## üìä Tipos para Configura√ß√£o

### Environment e Config:
```typescript
// ‚úÖ Correto - Tipos para configura√ß√£o
interface AppConfig {
  server: {
    port: number;
    host: string;
    bodyLimit: number;
  };
  redis: {
    host: string;
    port: number;
  };
  truncate: {
    maxLength: number;
    fields: string[];
  };
}

// Valida√ß√£o em runtime
function validateConfig(config: unknown): AppConfig {
  // usar Zod para valida√ß√£o
  return configSchema.parse(config);
}
```

## üîÑ Async/Await Patterns

### SEMPRE usar async/await (nunca .then()):
```typescript
// ‚úÖ Correto - async/await
async function processMultipleEvents(events: any[]): Promise<ProcessResult[]> {
  const results: ProcessResult[] = [];
  
  for (const event of events) {
    try {
      const result = await this.processEvent(event);
      results.push(result);
    } catch (error) {
      this.logger.error('Event processing failed:', error);
    }
  }
  
  return results;
}

// ‚ùå Incorreto - Promise chains
function processMultipleEvents(events: any[]) {
  return Promise.all(
    events.map(event => 
      this.processEvent(event).catch(error => {
        this.logger.error('Failed:', error);
      })
    )
  );
}
```

## üìã Type Guards e Valida√ß√£o

### Type Guards para Valida√ß√£o:
```typescript
// ‚úÖ Correto - Type guards
function isEventStructure(obj: any): obj is EventStructure {
  return (
    typeof obj === 'object' &&
    typeof obj.path === 'string' &&
    ['string', 'number', 'boolean', 'object', 'array', 'null', 'union'].includes(obj.type) &&
    typeof obj.optional === 'boolean' &&
    Array.isArray(obj.examples)
  );
}

// Uso
if (isEventStructure(data)) {
  // TypeScript sabe que data √© EventStructure
  console.log(data.path);
}
```

## üè∑Ô∏è Enums vs Union Types

### Prefer Union Types para Valores Est√°ticos:
```typescript
// ‚úÖ Correto - Union types
type EventType = 'message' | 'picture' | 'business_name' | 'delete_chat';
type LogLevel = 'debug' | 'info' | 'warn' | 'error';

// ‚ùå Evitar enums desnecess√°rios
enum EventType {
  MESSAGE = 'message',
  PICTURE = 'picture'
}
```

### Usar const assertions:
```typescript
// ‚úÖ Correto - const assertion
const TRUNCATE_FIELDS = [
  'base64', 
  'JPEGThumbnail', 
  'thumbnail', 
  'data', 
  'image'
] as const;

type TruncateField = typeof TRUNCATE_FIELDS[number];
```

## üé≠ Decorators e Metadata (Se Usar)

### Evitar decorators experimentais:
```typescript
// ‚ùå Evitar - decorators experimentais
@Injectable()
class EventProcessor {
  // implementa√ß√£o
}

// ‚úÖ Preferir - inje√ß√£o expl√≠cita
class EventProcessor {
  constructor(
    private dependencies: EventProcessorDependencies
  ) {}
}
```

## üìö Import/Export Patterns

### SEMPRE usar named exports:
```typescript
// ‚úÖ Correto - named exports
export class EventAnalyzer { }
export interface EventStructure { }
export type ProcessResult = { };

// ‚úÖ Correto - barrel exports em index.ts
export { EventAnalyzer } from './EventAnalyzer';
export { EventStructure } from './types';

// ‚ùå Evitar default exports
export default class EventAnalyzer { }
```

### Path mapping para imports limpos:
```typescript
// tsconfig.json
{
  "compilerOptions": {
    "paths": {
      "@/server/*": ["./src/server/*"],
      "@/types/*": ["./src/types/*"]
    }
  }
}

// ‚úÖ Import limpo
import { EventAnalyzer } from '@/server/services/EventAnalyzer';
```