---
globs: src/server/**/*.ts,*.ts
description: Regras para desenvolvimento backend do sistema webhook mapper
---

# Regras de Desenvolvimento Backend

## ğŸš€ Fastify Configuration
- SEMPRE usar Fastify ao invÃ©s de Express para performance superior
- Configurar bodyLimit para 100MB para suportar payloads grandes
- Usar plugins oficiais: @fastify/cors, @fastify/helmet, @fastify/rate-limit
- Implementar graceful shutdown em todos os serviÃ§os

```typescript
// âœ… Correto - ConfiguraÃ§Ã£o Fastify
const app = Fastify({
  logger: true,
  bodyLimit: 100 * 1024 * 1024 // 100MB
});
```

## ğŸ”„ Processamento AssÃ­ncrono
- TODOS os webhooks devem ser processados via queue (BullMQ)
- Responder IMEDIATAMENTE com 200 OK
- Nunca bloquear o webhook com processamento pesado
- Usar workers com concorrÃªncia configurÃ¡vel

```typescript
// âœ… Correto - Processamento assÃ­ncrono
app.post('/webhook', async (request, reply) => {
  await processor.addToQueue(request.body);
  return reply.code(200).send({ status: 'ok' });
});
```

## ğŸ“Š Logging Estruturado
- Usar Logger customizado com contexto
- Incluir sempre: timestamp, level, service, eventType
- Log de entrada e saÃ­da de todos os mÃ©todos importantes
- Evitar logs de dados sensÃ­veis

```typescript
// âœ… Correto - Log estruturado
this.logger.info({ 
  eventType: event.eventType,
  timestamp: Date.now(),
  action: 'processing_started' 
}, 'Starting event processing');
```

## ğŸ—„ï¸ Gerenciamento de Dados
- SQLite para metadados e estatÃ­sticas
- Sistema de arquivos para schemas gerados
- Redis para queue e cache temporÃ¡rio
- NUNCA salvar payloads completos no banco (apenas truncados)

## ğŸ›¡ï¸ Error Handling
- Sempre usar try/catch em operaÃ§Ãµes assÃ­ncronas
- Retornar 200 mesmo em erro (nÃ£o quebrar webhook)
- Implementar retry com backoff exponencial
- Logs detalhados de todos os erros

```typescript
// âœ… Correto - Error handling robusto
try {
  await this.processEvent(event);
} catch (error) {
  this.logger.error('Processing failed:', error);
  // Ainda retorna 200 para nÃ£o quebrar webhook
  return reply.code(200).send({ status: 'error' });
}
```

## ğŸ“ ValidaÃ§Ã£o e Tipos
- Usar Zod para validaÃ§Ã£o de entrada
- Interfaces TypeScript para todos os objetos
- ValidaÃ§Ã£o no boundary (entrada da API)
- Tipos explÃ­citos, evitar `any`

## ğŸ”§ DependÃªncia e InjeÃ§Ã£o
- ServiÃ§os devem ser injetÃ¡veis
- Constructor injection pattern
- Interfaces para abstraÃ§Ãµes
- Facilitar testes unitÃ¡rios

```typescript
// âœ… Correto - InjeÃ§Ã£o de dependÃªncia
export class EventProcessor {
  constructor(
    private analyzer: EventAnalyzer,
    private generator: SchemaGenerator,
    private fileManager: FileManager
  ) {}
}
```